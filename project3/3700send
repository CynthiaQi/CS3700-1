#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
import hashlib

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

class Sender(object):
  # init methods
  def __init__(self, dest):
    # data dependent
    self.sent_data_dict = dict()
    self.acked_data_dict = dict()

    self.cwnd = 1.0
    self.ssthresh = 10000.0

    self.add_incr = 0
    self.round_trip_time = 0.5
    self.last_sent_byte = 0

    self.dest = dest
    self.sock = self.init_socket()

  # set up the socket
  def init_socket(self):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
    sock.settimeout(TIMEOUT)
    return sock

  # main method for handling program
  def send(self):
    # Send first packet
    self.transmit_packet()

    # Now read in data, send packets
    while True:
      try:
        # Process any ACKs we receive
        (data, addr) = self.sock.recvfrom(MSG_SIZE)
        if (not self.process_ack(data)):
          # Determine whether to break the loop
          break
      except socket.timeout:
        log("[Error]: Socket timeout")
        # Calculate new congestion window
        self.calc_cong_wind_timeout()
        # Retransmit the originally sent packet
        self.retransmit_packets()

    self.transmit_eof()
  
  # Transmit EOF packet
  def transmit_eof(self):
    # Send several times to make sure it gets through
    for x in range(5):
      self.sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False, "checksum" : ""}), self.dest)
    log("[Sent EOF]: Stopping...")

  ## methods for sending data    

  # build a checksum from the data
  def build_checksum(self, data):
    data_string = ''.join([`x` for x in data])
    return hashlib.md5(data_string).hexdigest()

  # calc congestion window after a timeout
  def calc_cong_wind_timeout(self):
    # Multiplicative decrease
    self.ssthresh = max(self.cwnd / 2.0, 2.0)
    self.cwnd = 1.0
    log("[Sliding Window Timeout]: cwnd: " + str(self.cwnd) + " ssthresh: " + str(self.ssthresh))

  # calc congestion window after 3 duplicate acks are recieved
  def calc_cong_wind_3_dup_acks(self):
    # TCP Reno Fast Recovery
    self.ssthresh = (self.cwnd / 2.0)
    self.cwnd = self.ssthresh
    log("[Three Duplicate Acks]: cwnd: " + str(self.cwnd) + " ssthresh: " + str(self.ssthresh))

  # calc congestion window after an ack is received
  def calc_cong_wind_ack(self):
    if self.cwnd < self.ssthresh:
      # Slow start
      self.cwnd += 1.0
    else:
      # Congestion avoidance
      self.cwnd += 1.0 / self.cwnd
    log("[Sliding Window ACK]: cwnd: " + str(self.cwnd) + " ssthresh: " + str(self.ssthresh))

  # transmits packet
  def transmit_packet(self):
    # Transmit a number of packets equal to cwnd
    for x in range(int(self.cwnd)):
      # read in chunks of data
      data = sys.stdin.read(DATA_SIZE)
      sequence_num = SEQUENCE + (x * DATA_SIZE)

      if (len(data) > 0):
        # Attempt to send the next packet
        checksum = self.build_checksum([sequence_num, data])
        msg = json.dumps({"sequence": sequence_num, "data": data, "ack": False, "eof": False, "checksum" : checksum})
        if self.sock.sendto(msg, self.dest) < len(msg):
          log("[Error]: Unable to fully send data")
        else:
          log("[Send Data]: " + str(sequence_num) + " (" + str(len(data)) + ")")

        # Add packet to sent_data_dict
        self.sent_data_dict[str(sequence_num)] = msg
      else:
        # No remaining data. Stop the main loop if sent_data_dict is empty
        return len(self.sent_data_dict) != 0
    # Continue the main loop by default
    return True

  # retransmits unacked packets
  def retransmit_packets(self):
    # For each sent, unACKed packet
    for sequence_num in self.sent_data_dict.keys():
      # Attempt to retransmit
      msg = self.sent_data_dict[sequence_num]
      if self.sock.sendto(msg, self.dest) < len(msg):
        log("[Error]: Unable to fully resend packet")
      else:
        log("[Resend Data]: " + sequence_num)

  ## methods for processing acks

  # decode message from receiver into a usable json form
  def parse_receiver_msg(self, data):
    return json.loads(data)

  # handle information from ack
  def process_ack(self, data):
    global SEQUENCE
    try:
      decoded = self.parse_receiver_msg(data)
      sequence_num_string = str(decoded['ack'])
      expected_seq = decoded['expected_sequence']

      # If we got an ACK for an unACKed packet, send the next packet
      if sequence_num_string in self.sent_data_dict.keys():
        log("[Recv ACK]: " + sequence_num_string)

        # Add ACKed packet to acked_data_dict
        self.acked_data_dict[sequence_num_string] = 1
        # Remove ACKed packet from sent_data_dict
        del self.sent_data_dict[sequence_num_string]
        # Increment the sequence number to expect the next packet
        SEQUENCE += DATA_SIZE

        # create an ack entry for the expected sequence 
        # this will cause retransmission of missing packet if 3 acks recieved
        if (decoded['ack'] > decoded['expected_sequence']):
          self.acked_data_dict[expected_seq] = self.acked_data_dict.get(expected_seq, 0) + 1

          if self.acked_data_dict[decoded['expected_sequence']] == 3:
            self.handle_3_dup_ack(decoded)
            del self.acked_data_dict[decoded['expected_sequence']]
        #TODO convert code to work with expected sequence 
        else:
          # Calculate the new congestion window
          self.calc_cong_wind_ack()
          # Transmit next set of packets if every sent packet was ACKed
        
        if len(self.sent_data_dict) == 0:
          # (Returning this allows us to determine whether to break the main loop)
          return self.transmit_packet()
    except (ValueError, KeyError, TypeError):
      log("[Error]: Received corrupt packet")
    # By default, do not break the main loop
    return True

  # handle the duplicate acks
  def handle_3_dup_ack(self, data):
    self.calc_cong_wind_dup_acks()
    self.retransmit_packets()


if __name__ == '__main__':
  # bind to localhost and an ephemeral port
  IP_PORT = sys.argv[1]
  UDP_IP = IP_PORT[0:IP_PORT.find(":")]
  UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
  dest = (UDP_IP, UDP_PORT)
  MSG_SIZE = 1500
  DATA_SIZE = 1000
  TIMEOUT = 1
  SEQUENCE = 0

  sender = Sender(dest)
  sender.send()
