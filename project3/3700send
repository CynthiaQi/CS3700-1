#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
import hashlib

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

class Sender(object):
	# init methods
	def __init__(self, dest):
		# data dependent
		self.sent_data_dict = dict()
		self.acked_data_dict = dict()

		# initialized vars 
		self.cong_wind = 1
		self.add_incr = 0
		self.round_trip_time = 0.5
		self.slow_start_thresh = 50
		self.last_sent_byte = 0

		# blank counters
		self.packet_timers = {}
		self.dup_ack_counters = {}

		self.dest = dest
		self.sock = self.init_socket()

	# set up the socket
	def init_socket(self):
		sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
		sock.settimeout(TIMEOUT)
		return sock
		
	def init_acked_data_dict(self):
		pass

	def init_sent_data_dict(self):
		pass

	# main method for handling program
	def send(self):
		global SEQUENCE
		# Send first packet
		self.transmit_packet()

		# Now read in data, send packets
		while True:
			try:
				result = self.sock.recvfrom(MSG_SIZE)
				(data, addr) = result
				try:
					decoded = self.parse_receiver_msg(data)

					# If there is an ack, send next packet
					if decoded['ack'] == SEQUENCE:
						log("[Recv ACK]: " + str(SEQUENCE))
						# Increment the sequence number to expect the next packet
						SEQUENCE += DATA_SIZE

						# Try to send next packet; break if no more data
						if (not self.transmit_packet()):
							break
				except (ValueError, KeyError, TypeError):
					log("[Error]: Received corrupt packet")
			except socket.timeout:
				log("[Error]: Socket timeout")
				self.retransmit_packet()

		self.transmit_eof()
	
	# Transmit EOF packet
	def transmit_eof(self):
		# Send several times to make sure it gets through
		for x in xrange(0, 5):
			self.sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False, "checksum" : ""}), self.dest)
		log("[Sent EOF]: Stopping...")

	## methods for sending data    

	# build a checksum from the data
	def build_checksum(self, data):
		data_string = ''.join([`x` for x in data])
		return hashlib.md5(data_string).hexdigest()

	# return effective window
	def get_effective_wind(self):
		pass

	# calc congestion window after a timeout
	def calc_cong_wind_timeout(self):
		pass

	# calc congestion window after duplicate acks are recieved
	def calc_cong_wind_dup_acks(self):
		pass

	# calc congestion window after an ack is received
	def calc_cong_wind_ack(self):
		pass

	# transmits packet
	def transmit_packet(self):
		# read in chunks of data
		data = sys.stdin.read(DATA_SIZE)

		if (len(data) > 0):
			msg = json.dumps({"sequence": SEQUENCE, "data": data, "ack": False, "eof": False, "checksum" : ""})

			if self.sock.sendto(msg, self.dest) < len(msg):
				log("[Error]: Unable to fully send data")
			else:
				log("[Send Data]: " + str(SEQUENCE) + " (" + str(len(data)) + ")")

			# Add packet to sent_data_dict
			self.sent_data_dict[str(SEQUENCE)] = msg
			return True
		else:
			return False

	# send packets from the effective window that haven't been transmitted
	def send_new_packets(self):
		pass

	# retransmits unacked packet
	def retransmit_packet(self):
		msg = self.sent_data_dict[str(SEQUENCE)]
		if self.sock.sendto(msg, self.dest) < len(msg):
			log("[Error]: Unable to fully resend packet")
		else:
			log("[Resend Data]: " + str(SEQUENCE))

	## methods for processing acks

	# decode message from receiver into a usable json form
	def parse_receiver_msg(self, data):
		return json.loads(data)

	# handle information from ack
	def process_ack(self, data):
		pass

	# handle a duplicate ack
	def handle_dup_ack(self, data):
		pass


if __name__ == '__main__':
	# bind to localhost and an ephemeral port
	IP_PORT = sys.argv[1]
	UDP_IP = IP_PORT[0:IP_PORT.find(":")]
	UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
	dest = (UDP_IP, UDP_PORT)
	MSG_SIZE = 1500
	DATA_SIZE = 1000
	TIMEOUT = .2
	SEQUENCE = 0

	sender = Sender(dest)
	sender.send()
